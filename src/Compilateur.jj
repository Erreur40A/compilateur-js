options {
    static = false;
}

options {
    static = false;
}

PARSER_BEGIN(Compilateur)

import java.io.*;
import java.util.ArrayList;
import java.io.*;
import java.util.ArrayList;
import AST.*;

public class Compilateur {
    public static void main(String[] args){
        if(args.length != 1){
            throw new IllegalArgumentException("Il faut obligatoirement UN FICHIER en argument");
        }

        BufferedReader reader = readerFile(args[0]);
        String pathJSM = createFile(args[0]);
        ArrayList<String> line = new ArrayList<String>();
        String assembleur=null;
        viderFile(pathJSM);

        try {
            while((line=splitLine(reader)) != null){
                for (String item : line) {
                    Compilateur parseur = new Compilateur(new StringReader(item));
                    ExpressionA eA = parseur.mainNT();

                    if(eA!=null)
                        writeFile(pathJSM, eA.toAssembly());
                }
            }
        }catch (TokenMgrError e){
            e.printStackTrace();
        }catch (ParseException e){
            e.printStackTrace();
        }
    }

    public static ArrayList<String> splitLine(BufferedReader reader){
        ArrayList<String> items = new ArrayList<String>();
        String line=readerLine(reader);

        if(line!=null)
            for(String item : line.split(";")){
                item=item.replaceAll("[\n\\s\t]","");
                item+=";";
                items.add(item);
            }
        else
            return null;

        return items;
    }

    public static String readerLine(BufferedReader reader){
        String res=null;
        try {
            res = reader.readLine();
        }catch (IOException e) {
            System.out.println("readLine: " + e.getMessage());
        }

        return res;
    }

    public static BufferedReader readerFile(String pathFile){
        BufferedReader res=null;
        try {
            FileReader f = new FileReader(pathFile);
            res = new BufferedReader(f);
        }catch (IOException e) {
            System.out.println("readFile: " + e.getMessage());
        }

        return res;
    }

    public static String createFile(String path){
        path = path + ".jsm";
        File f = new File(path);

        if(!f.exists()){
            try {
                f.createNewFile();
            } catch (IOException e) {
                return f.getPath();
            }
        }

        return f.getPath();
    }

    public static void closeBufferedReader(BufferedReader reader){
        if (reader != null) {
            try {
                reader.close();
            } catch (IOException e) {
                System.out.println("closeBufferedReader: " + e.getMessage());
            }
        }
    }

    public static void closeBufferedWriter(BufferedWriter writer){
        if (writer != null) {
            try {
                writer.close();
            } catch (IOException e) {
                System.out.println("closeBufferedWriter: " + e.getMessage());
            }
        }
    }

    public static void viderFile(String path){
        BufferedWriter vider_contenue = null;

        try {
            vider_contenue = new BufferedWriter(new FileWriter(path, false));
            vider_contenue.write("");
        } catch (IOException e) {
            System.out.println("viderFile: " + e.getMessage());
        } finally {
            closeBufferedWriter(vider_contenue);
        }
    }

    public static void writeFile(String path, String contenu){
        BufferedWriter writer = null;
        
        try {
            writer = new BufferedWriter(new FileWriter(path, true));
            writer.write(contenu);
            writer.newLine();
        } catch (IOException e) {
            System.out.println("writeFile ecrire contenue: " + e.getMessage());
        } finally {
            closeBufferedWriter(writer);
        }
    }
}
PARSER_END(Compilateur)

SKIP :
{ " " | "\t" | "\n" | "//" : FinComMonoLn | "/*" : FinComMultiLn}

<FinComMonoLn> SKIP :
{
    "\n" : DEFAULT
}

<FinComMultiLn> SKIP :
{
    "*/" : DEFAULT
}

<FinComMonoLn> MORE :
{
  <~[]>
}

<FinComMultiLn> MORE :
{
  <~[]>
}

TOKEN :
{ < NOMBRE: (["0"-"9"])+ ("." (["0"-"9"])*)? >
  | <EOL: ";" >
  //Priorit√© boolean: +,-,*,/ prioritaire sur ==, <=
  | <BOOLEAN: "True" | "False" | "true" | "false"> 
  | <EGALITE: "==" >
  | <DIFFERENT: "!=" >
  | <PPETITOUE: "<=" >
  | <PGRANDOUE: ">=" >
  | <ET: "&&" >
  | <NAN: "NaN" >
  | <NOMBRESCI: <NOMBRE> "e" ("-")? (["0"-"9"])+ >
  | <COMMANDE: "import" >
  | <IDENTIFIANT: (["a"-"z"] | ["A"-"Z"] | "$" | "_") (["a"-"z"] | ["A"-"Z"] | ["1"-"9"] | "$" | "_")* >

}

//Pour les tests sur le fichier test il faut que True et False commence par un majuscule et pas une minuscule

ExpressionA mainNT () :
{
    ExpressionA e;
}
{ (e=expression()) <EOL> {return e;}}

ExpressionA expression () :
{
    ExpressionA gauche;
    ExpressionA droite;
    ExpressionA res;
}
{ (gauche=terme() {res=gauche;}
    ("+" (droite=terme()) {gauche=new Plus(gauche, droite); res=gauche;}
    | "-" (droite=terme()) {gauche=new Moins(gauche, droite); res=gauche;}
    |<EGALITE> (droite=terme()) {gauche=new Egalite(gauche, droite); res=gauche;}
    |<PPETITOUE> (droite=terme()) {gauche=new PPetitE(gauche, droite); res=gauche;}
    |<PGRANDOUE> (droite=terme()) {gauche=new PGrandE(gauche, droite); res=gauche;}
    |<DIFFERENT> (droite=terme()) {gauche=new NotEq(gauche, droite); res=gauche;}
    | "<" (droite=terme()) {gauche=new PPetit(gauche, droite); res=gauche;}
    | ">" (droite=terme()) {gauche=new PGrand(gauche, droite); res=gauche;}
    | <ET> (droite=terme()) {gauche=new Et(gauche, droite); res=gauche;}
    )* {return res;})
  |importer()
}

ExpressionA terme () :
{
    ExpressionA gauche;
    ExpressionA droite;
    ExpressionA res;
}
{ gauche=facteur() {res=gauche;}
    ("*" (droite=facteur()) {gauche=new Mult(gauche, droite); res=gauche;}
    |"/" (droite=facteur()) {gauche=new Div(gauche, droite); res=gauche;}
    )* {return res;}
}

ExpressionA facteur () :
{
    ExpressionA e;
    Token t;
}
{ "(" (e=expression()) ")" {return e;}
    | "-" (e=facteur()) {return new Neg(e);}
    | "!" (e=facteur()) {return new Nega(e);}
    | t=<NOMBRE> {return new Num(Float.parseFloat(t.image));}
    | t=<NOMBRESCI> {return new Num(Float.parseFloat(t.image));}
    | t=<NAN> {return new Num(Float.parseFloat(t.image));}
    | t=<BOOLEAN> {return new Bool(Boolean.parseBoolean(t.image));}
}

//A FAIRE
ExpressionA importer () :
{
    Token com;
    Token arg;
}
{
    (com=<COMMANDE>) (arg=<IDENTIFIANT>) ".jsm" {return new Import(com.image, arg.image);}
}