PARSER_BEGIN(Compilateur)


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.File;
import AST.*;

public class Compilateur {
    public static void main(String[] args) {
        if(args.length != 1){
           throw new IllegalArgumentException("Il faut obligatoirement UN FICHIER en argument");
        }

        try {
            BufferedReader reader = readerFile(args[0]);
            Compilateur parseur = new Compilateur(reader);
            ExpressionB eB=parseur.mainNTBool();
            String pathJSM=createFile(args[0]);

            writeFile(pathJSM, eB.toAssembly());
        } catch (TokenMgrError e) {
            //System.out.println("Token Ceci n'est pas une expression arithm\u00e9thique");
            e.printStackTrace();
        } catch (ParseException e){
            //System.out.println("Parseur Ceci n'est pas une expression arithm\u00e9thique");
            e.printStackTrace();
        }
    }

    public static BufferedReader readerFile(String pathFile){
        BufferedReader res=null;
        try {
            FileReader f = new FileReader(pathFile);
            res = new BufferedReader(f);
        }catch (IOException e) {
            System.out.println("readFile: " + e.getMessage());
        }

        return res;
    }

    public static String createFile(String path){
        path = path + ".jsm";
        File f = new File(path);

        if(!f.exists()){
            try {
                f.createNewFile();
            } catch (IOException e) {
                return f.getPath();
            }
        }

        return f.getPath();
    }

    public static void closeBufferedWriter(BufferedWriter writer){
        if (writer != null) {
            try {
                writer.close();
            } catch (IOException e) {
                System.out.println("writeFile fermeture buffeur : " + e.getMessage());
            }
        }
    }

    public static void writeFile(String path, String contenu){
        BufferedWriter writer = null;

        try {
            writer = new BufferedWriter(new FileWriter(path));
            writer.write(contenu);
        } catch (IOException e) {
            System.out.println("writeFile ecrire contenue: " + e.getMessage());
        } finally {
            closeBufferedWriter(writer);
        }
    }
}
PARSER_END(Compilateur)

SKIP :
{ " " | "\t" | "\n" }

TOKEN :
{ < NOMBRE: (["0"-"9"]) (["0"-"9"])* (["."])? (["0"-"9"])* >
  | <EOL: ";" >
  | <BOOLEAN: "True" | "False" >
  | <EGALITE: <NOMBRE> "==" <NOMBRE> | <BOOLEAN> "==" <BOOLEAN>>
  | <PPETITOUE: <NOMBRE> "<=" <NOMBRE> >
}

//Expression arithmétique

ExpressionA mainNT () :
{
    ExpressionA e;
}
{ (e=expression()) <EOL> {return e;}}

ExpressionA expression () :
{
    ExpressionA gauche;
    ExpressionA droite;
    ExpressionA res;
}
{ gauche=terme() {res=gauche;}
    ("+" (droite=terme()) {gauche=new Plus(gauche, droite); res=gauche;}
    | "-" (droite=terme()) {gauche=new Moins(gauche, droite); res=gauche;}
    )* {return res;}
}

ExpressionA terme () :
{
    ExpressionA gauche;
    ExpressionA droite;
    ExpressionA res;
}
{ gauche=facteur() {res=gauche;}
    ("*" (droite=facteur()) {gauche=new Mult(gauche, droite); res=gauche;}
    |"/" (droite=facteur()) {gauche=new Div(gauche, droite); res=gauche;}
    )* {return res;}
}

ExpressionA facteur () :
{
    ExpressionA e;
    Token t;
}
{ "(" (e=expression()) ")" {return e;}
    | "-" (e=facteur()) {return new Neg(e);}
    | t=<NOMBRE> {return new Num(Float.parseFloat(t.image));}
}

/*
Priorité boolean:
+,-,*,/ prioritaire sur ==, <=
*/

//Expression booleenne 
//Pour les tests sur le fichier test il faut que True et False commence par un majuscule et pas une minuscule

ExpressionB mainNTBool () :
{
    ExpressionB e;
}
{ (e=expressionBool()) <EOL> {return e;}}

ExpressionB expressionBool() :
{
    ExpressionB res=null;
    ExpressionA gauche;
    ExpressionA droite;
}
{   
    gauche=termeBool()
    (<EGALITE> droite=termeBool() {res=new Egalite(gauche, droite);}
    |<PPETITOUE> droite=termeBool() {res=new PPetitE(gauche, droite);}
    )* {return res;}
}

ExpressionA termeBool() :
{
    Token t;
    ExpressionA eA;
}
{
    t=<BOOLEAN> {return new Bool(Boolean.parseBoolean(t.image));}
    |eA=expression() {return eA;}
}